# 공통 CS 질문

# 공통 CS 질문

- vs 는 두 가지에 대해 설명하고 장단점을 말하는 식으로 하면 좋을 것 같습니다.

## 네트워크

- Session vs Cookie
    - 상태저장을 위한 수단입니다. 웹 브라우저에 대한 상태를 저장하는데 이때 사용자 웹 브라우저에서 생성하고 저장하는 것을 쿠키라고 합니다. 웹 브라우저가 꺼져도 상태가 저장됩니다.(로컬의 저장)클라이언트 서버에서 저장하는 것을 세션이라고 합니다. 세션은 웹 브라우저가 꺼져도 저장됩니다.(서버의 상태값으로 저장)
    
    - 둘 다 상태를 저장하지 않는 HTTP통신에서 상태를 저장하기 위한 수단
    - 세션 : 서버에 상태를 저장. 클라이언트에는 세션ID를 전달
    - 쿠키 : 클라이언트에서 상태를 파일 형태로 키-값 쌍으로 저장
    
    ```
    -   HTTP의 프로토콜의 특징이자 약점을 보완하기 위해 사용
    
    -   쿠키는 클라이언트에 저장되는 키와 값(key, value)이 들어있는 작은 데이터 파일
    
    -   쿠키는 이름, 값, 만료 날짜 등이 들어 있음
    
    -   세션은 서버에 클라이언트 상태를 저장하는 기술, 논리적인 세션으로 연결
    ```
    
    [쿠키vs세션](https://www.notion.so/4723abeffebd4d4380d899327d20bc59)
    
    - stateless한 HTTP 통신에서 상태를 저장하기 위한 수단
    - 세션: 서버에 상태를 저장한다.
    - 쿠키: 클라이언트에 key, value 쌍으로 값을 저장한다. 브라우저를 종료돼도 저장된다.
        - 장점: 서버 부하가 적다.
        - 단점: 크기 제한이 있다. 하나의 쿠키 당 4KB
- TCP vs UDP
    - TCP : 각각의 패킷을 정해진 경로로 전달, 전송되었는지 확인 O, 높은 신뢰성 보장하지만 속도가 느리다.
    - UDP : 각각의 패킷을 다른 경로로 전달, 전송되었는지 확인 X, 전송을 보장하지 않지만 속도가 빠르다.
    
    - TCP 와 UDP 는 4계층 전송계층에 있는 데이터의 전송 방식에 대한 프로토콜이다.
    - TCP 는 연결 지향적이다. 흐름제어,혼잡제어 등을 하기에 높은 신뢰성을 보장한다. 소켓통신 과정에서는 서버의 소켓생성,주소할당,요청기다림,요청응답 이고 클라이언트에서는 소켓생성,주소할당,연결요청 등을 한다.
    - UDP 는 비연결적이다. 속도가 중요해서 계속 데이터를 보내기 위한 설정이기 때문에 제어가 힘들다. 데이터소캣을 쓸 때 데이터를 마구 송수신한다.
    
    - TCP
        - 연결형 프로토콜. 네트워크에 연결된 컴퓨터에서 프로그램 간 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
        - 전송 데이터의 흐름을 제어하고 데이터의 에러 유무를 검사한다.
        - 수신측에서 잘못 전송된 패킷에 대해 재전송 요구
        - 1:1 통신
    - UDP
        - 비연결형 프로토콜. 신뢰성을 보장하지 않는 비접속형 통신 제공
        - 메시지 분실 or 송신된 순서와 다른 순서로 수신될 수 있다.
        - 통신 수립 단계가 없어 신속하고 신뢰적이지 못함.
        - 데이터 재전송 X
        - 1:1, 1:n, n:n 통신
- 3-way handshake & 4-way handshake 방식에 대해 설명하시오.
    
    3-way handshake : TCP 연결과정
    
    1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 된다
    2. 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 서버는 SYN_RECEIVED 상태가 된다
    3. 클라이언트는 서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 서버 상태가 ESTABLISHED 이다
    
    4-way handshake : TCP 연결 종료과정
    
    1. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.
    2. 서버는 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 ****CLOSE_WAIT상태다
    3. 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.
    4. 클라이언트는 확인했다는 메시지를 보낸다.
    - 클라이언트는 연결 종료 후에도 잔여 패킷을 기다리는 시간이 있는데, 이 상태를 TIME_WAIT라고 한다
    
    3-way handshake: TCP의 통신 수립을 말함.
    
    1. 수신측에 플래그 비트 중 SYN을 1로 설정하여 전송
    2. 수신측은 SYN을 1로 받았으면 SYN을 1, ACK를 1로 송신측에 전송
    3. 송신측은 다시 ACK를 1로 설정하여 수신측에 전달하면, 통신 수립된 것이다. → 신뢰성 확보, 통신 수립 단계를 거치기 때문에 지연 발생.
    
    4-way handshake: TCP의 연결 해제과정
    
    1. 클라이언트에서 FIN 플래그를 전송하여 연결 해제를 알림
    2. 서버는 클라이언트의 요청을 받아 확인 메시지로 ACK 전송
        
        2-1. 데이터를 모두 보낼 때까지 잠시 TIME_OUT 된다.
        
    3. 데이터를 모두 전송하고 통신이 끝나면 연결이 종료되었다고 클라이언트에 FIN 플래그 전송
    4. 클라이언트는 FIN 메시지를 확인했다는 메시지로 ACK를 전송한다.
        
        4-1. ACK메시지를 받은 서버는 연결을 close 한다.
        
        4-2. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 잉여 패킷을 기다리는 TIME_WATE 과정을 거친다.
        
- Rest 란 ? 당근마켓 면접
    
    웹의 장점을 최대한 활용할 수 있는 아키텍처로써 자원을 정의하고 자원에 대한 주소를 지정하는 스타일.
    
    특징
    
    ```
     1. Uniform(유니폼 인터페이스)
    
     2. Stateless(무상태성)
    
     3. Cacheable(캐시가능)
    
     4. Self-descriptiveness(자체 표현 구조)
    
     5. Client-server 구조
    
     6. 계층형 구조
    ```
    
    “웹을 무너뜨리지 않고 어떻게 HTTP 프로토콜을 발전 시킬 수 있을까?”에 대한 고민으로 시작된 아키텍쳐.
    
    REST API는 REST 아키텍쳐를 따르는 API로,
    
    REST의 특성 중 하나인 유니폼 인터페이스 제약조건으로 현재 대부분의 REST API는 엄밀히 말해 REST하지 않다. (RESTful 하다)
    
- GET과 POST의 차이
    - GET 방식 : URL을 통해 모든 파라미터를 전달하기 때문에 주소창에 전달 값이 노출됨. URL 길이가 제한이 있기 때문에 전송 데이터 양이 한정되어 있고, 형식에 맞지 않으면 인코딩해서 전달해야 함
    - POST 방식 : HTTP BODY에 데이터를 포함해서 전달함. 웹 브라우저 사용자의 눈에는 직접적으로 파라미터가 노출되지 않고 길이 제한도 없음.
    - 보통 GET은 가져올 때, POST는 자원을 생성하는 역할에 활용한다.
- OSI 7 계층을 말하고 각 계층의 하는 일
    - 
        
        OSI 7 계층이란 국제표준화기구에서 제안한 통신 프로토콜로,
        
        물리, 데이터링크, 네트워크, 전송, 세션, 포현, 응용 계층으로 이루어져 있습니다.
        
        **1)** **물리계층**
        
        통신케이블을 통해 데이터를 전송하는 계층입니다. 장비로는 통신 케이블, 허브가 존재합니다.
        
        **2)** **데이터링크계층**
        
        송수신하는 정보가 안전하게 전달하도록 서비스하는 계층입니다. 이 계층에서는 MAC address를 가지고 통신을 하며 전송 단위가 프레임이며 오류 검출과 흐름 제어를 통해 안전하게 도달하도록 합니다.
        
        **3)** **네트워크 계층**
        
        시스템간 연결성과 경로 선택을 제공하는 역할을 하는 계층입니다. IP 주소를 이용하여 라우팅 프로토콜이 연결된 네트워크를 통한 최적경로를 선택합니다.
        
        **4)** **전송 계층**
        
        데이터의 전송을 위한 논리적인 연결을 하는 대문같은 역할을 합니다.
        
        신뢰성 있는 전송을 보장하기 위해 오류 검출 및 복구와 흐름 제어를 제공합니다.
        
        **5) 세션 계층**
        
        이 계층은 어플리케이션간 세션을 구축하고 관리하며 종료하는 역할을 합니다.
        
        **6) 표현계층**
        
        세션 계층 간의 주고받는 인터페이스를 일관성 있게 제공합니다. (+ 암호화 기능 수행)
        
        **7) 응용계층 ( 어플리케이션 계층)**
        
        사용자가 네트워크에 접근할 수 있도록 서비스를 제공한다.
        
        이 계층에 속한 프로토콜로는 HTTP, FTP, SMTP 등이 있습니다.
        
- TCP/IP 프로토콜의 각 계층에 대해 설명하시오
    1. 네트워크 액세스 계층
        - OSI 7계층의 물리계층과 데이터 링크 계층에 해당한다.
        - 물리적인 주소로 MAC을 사용한다.
        - LAN, 패킷망, 등에 사용된다.
    2. 인터넷 계층
        - OSI 7계층의 네트워크 계층에 해당한다.
        - 통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당한다.
        - 프로토콜 – IP, ARP, RARP
    3. 전송 계층
        - OSI 7계층의 전송 계층에 해당한다.
        - 통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당한다.
        - 프로토콜 – TCP, UDP
    4. 응용 계층
        - OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당한다.
        - TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.
        - 프로토콜 – FTP, HTTP, SSH
- Web Server 와 WAS ( web application server ) 의 차이
    - Web Server : 클라이언트로부터 HTTP 요청을 받아서 정적 컨텐츠를 제공하는 프로그램
    - WAS : 다양한 비즈니스 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 서버 (ex- DB조회)
    - Web Server는 WAS의 subset이다.
    - Web Server의 기능
        1. 정적인 컨텐츠 제공(WAS를 거치지않고 바로 자원 제공)
        2. 동적인 컨텐츠 제공을 위한 요청 전달. 클라이언트의 요청(Request)을 WAS에 보내고 WAS가 처리한 결과를 클라이언트에게 전달(응답Response)한다
- HTTP 와 HTTPS 의 차이
    - HTTP는 통신에서 텍스트를 이용하지만 HTTPS는 TLS 또는 SSL 프로토콜을 이용해 데이터를 암호화
    - 기본적으로 HTTP는 80번 포트를 사용하고, HTTPS는 443번 포트를 사용한다
    - URI가 HTTP는 `http://`로 시작하고, HTTPS는 `https://`로 시작한다
    - 참고)
    - https는 대칭키 암호화를 사용하며 다음과 같은 과정을 거친다.
        1. 클라이언트가 서버에게 접속요청을 하면 서버는 CA에서 발급받은 인증서를 보낸다. 인증서에는 CA의 비밀키로 암호화된 사이트 정보,공개키가 들어있다.
        2. 클라이언트는 인증서를 받아 CA의 공개키로 복호화하여 접속요청한 서버가 신뢰할만한지 검증한다.
        3. 복호화가 되면 인증서가 신뢰할만하기 때문에 데이터를 주고받을 대칭키를 생성한다.
        4. 대칭키를 서버의 공개키로 암호화하여 서버에게 전송한다.
        5. 서버는 자신의 비밀키로 클라이언트가 보낸 대칭키를 복호화한 뒤 그 대칭키를 통해 데이터를 주고받는다.
- URL을 브라우저에 입력한 다음, 브라우저가 응답을 받기까지의 과정
    
    [https://parksb.github.io/article/36.html](https://parksb.github.io/article/36.html)
    
    [https://velog.io/@directorhwan59/웹-브라우저에-URL을-입력하고-첫-화면이-출력되기까지](https://velog.io/@directorhwan59/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%95%98%EA%B3%A0-%EC%B2%AB-%ED%99%94%EB%A9%B4%EC%9D%B4-%EC%B6%9C%EB%A0%A5%EB%90%98%EA%B8%B0%EA%B9%8C%EC%A7%80)
    
    1. 올바른 URL 형식 체크
    2. DNS 프로토콜
        - 도메인을 ip주소로 변환하는 과정
        - UDP 프로토콜 사용
        - ip를 찾을 때까지 로컬 DNS 서버부터 루트 DNS 서버까지 찾아간다
        - 찾은 IP의 MAC주소를 얻기 위해 ARP 프로토콜이 사용된다
    3. TCP 연결
        - 클라이언트는 HTTP GET 요청을 보내기 위해 소켓을 생성
        - 3-way handshake 과정을 통해 서버와 TCP 연결
        - HTTPS를 사용하면 TLS handshake 과정도 필요
    4. HTTP 메세지 전송
        - 클라이언트는 HTTP GET 메세지를 만들고 URL을 담는다
        - 소켓을 이용해서 서버로 패킷을 전송
        - [어플리케이션 계층] HTTP 패킷 : HTTP 메세지
        - [전송 계층] TCP 세그먼트 : 패킷 + TCP헤더. 송신&발신 포트번호, 순서번호, 확인번호 등을 저장
        - [네트워크 계층] IP 데이터그램 : TCP 세그먼트 + 헤더. 버전, 식별자, 프로토콜 등을 저장
        - [데이터 계층] 이더넷 프레임 : 프레임을 스위치를 통해 전송
    5. 서버의 응답
        - 서버는 TCP 소켓에서 HTTP GET 메시지를 읽고, 응답 메시지를 만든다
        - HTTP 응답 메시지의 body에 요청받은 콘텐츠를 담아 TCP 소켓으로 전송한다
- http 버전별 특징
    1. http 0.9
        
        1.1. GET 메소드만 사용가능
        
        1.2. 헤더가 존재하지 않아 HTML 파일만 전송 가능했다.
        
        1.3. 오류 및 상태 코드가 존재하지 않는다.
        
    2. http 1.0
        
        2.1. POST, HEAD 메소드 추가
        
        2.2. 헤더가 존재하여 이제 HTML 파일 외의 파일도 전송 가능
        
        2.3. 오류 및 상태 코드가 생겼다.
        
    3. http 1.1
        
        3.1. PUT, PATCH, DELETE 등의 메소드 추가
        
        3.2. 헤더에 `Connection: keep-alive` 속성을 추가하여 지속적으로 연결이 가능하게 됨
        
        3.3. 파이프라이닝을 지원하지만 응답이 지연되는 경우가 발생하게 됨
        
    4. http 2.0
        
        4.1. HTTP/2에서는 여러 파일을 한번에 병렬 전송하여, 이러한 문제를 해결하였다.
        

## 운영체제

- 프로세스 vs 쓰레드
    - **프로세스** : 프로그램을 메모리 상에서 실행중인 작업
    - **스레드** : 프로세스 안에서 실행되는 여러 흐름 단위
    
    차이)
    
    - 프로세스는 운영체제로부터 독립된 시간,공간 자원을 할당받아서 실행된다는 점이고, 스레드는 한 프로세스 내에서 많은 자원을 공유하면서 병렬적으로 실행된다는 것
    - 프로세스는 별도의 주소 공간에서 실행되며 다른 프로세스
- 콘텍스트 스위칭 이란?
    - 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 작업.
    - 프로세스의 상태는 PCB에 저장되어 있다.(PCB는 운영체제에 존재하는 자료구조)
    - 작업중인 프로세스에 대한 정보가 Context, 작업을 중단했을 때의 Context 정보는 프로세스가 전환될 때 PCB에 저장된다. 이후에 자신의 차례가 다시 왔을 때 PCB에 저장된 상태에서 작업을 재개하면 된다.
- 멀티 쓰레드 프로그래밍이란?
    
    여러 쓰레드를 동시에 실행시키는 프로그래밍
    
    - 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것
- 멀티 쓰레드 vs 멀티 프로세스
    - 멀티 쓰레드 : 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것
    - 멀티 프로세스: 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것을 의미한다.
    - 멀티 프로세스: 각 프로세스가 독립적인 메모리를 가지고 별도로 실행된다.
    - 멀티 스레드: 각 스레드가 자신이 속한 프로세스의 메모리를 공유한다. 그래서 **시스템 자원의 낭비가 적고** 하나의 스레드가 작업할 떄 다른 스레드가 별도의 작업을 할 수 있기 때문에 **사용자와의 응답성**도 좋아진다.
- 임계 영역
- 페이징 기법
- 데드락, 교착상태 해결
- 프로세스 스케줄링
    - 선점 스케줄링
    - 비선점 스케줄링
- 인터럽트
    1. 현재 실행중인 작업을 중단하고 발생한 상황을 처리한 후, 다시 실행중인 작업으로 복귀하는 것

## 자료구조/알고리즘

- 배열 vs 링크드리스트
    
    
    - 배열은 연속된 공간을 할당한다. 그래서 데이터의 주소가 연속적이여서 데이터를 찾아가는데 굉장히 빠르다. 다만, 처음에 공간을 할당하는 형태이기 때문에 이후 배열에 추가적인 공간을 추가하거나, 기존공간을 삭제하는데 어려움이 있습니다.
    - 리크드 리스트는 데이터를 가진 노드들이 꼬리에 꼬리를 물고 연결되어 있습니다. 그래서 데이터의 주소는 산발적입니다. 데이터를 찾으려면 Head ( 처음 ) 에서부터 해당 위치까지 탐색하는 시간이 걸립니다. 다만, 주소가 산발적이기 때문에, 중간의 리스트에 데이터를 추가하거나 중간의 데이터를 삭제할 때 , 각각의 노드의 주소들만 바꾸면 되어서 쉽습니다.
    
    - 데이터에 대한 **접근 속도**는 **배열**이 더 빠르다. 인덱스를 이용하여 접근하면 O(1), 연결리스트는 최소 한 번은 리스트를 순회해야하기 때문에 O(n)
    - 데이터 **삽입,삭제 속도**는 주로 연결리스트가 빠르다.
- 큐 vs 스택
    
    
    - 큐는 FIFO 를 하는 리스트입니다. 큐 같은경우는 처음 들어오는 것을 앞에 두고 HEAD 의 주소는 맨 처음 들어온 것이며 , 꺼내 쓸 때는 맨 앞에 있는 데이터를 꺼내고, HEAD 의 주소를 그다음 데이터로 지정합니다.
    - 스택은 FILO 를 하는 리스트입니다. 스택 같은 경우 새로 들어오는 것을 TOP 으로 하고 , 꺼내 쓸 때는 맨 마지막에 들어온 데이터를 꺼내고, TOP 의 주소를 그 다음으로 들어왔던 데이터로 지정합니다.
    
    +)
    
    - 스택은 대표적으로 프로그램을 수행할 때 사용되고, 큐는 현재 수행중인 프로세스를 관리할 때(컴퓨터 안에 여러 개의 프로세스가 수행중일 때, 새로운 프로세스가 수행되어야하는 경우 기존에 수행되던 프로세스 중에 가장 먼저 메모리에 올라온 프로세스가 실행되고 새로운 프로세스를 메모리에 올린다)
- 힙 vs 우선순위큐
    
    
    - 힙은 기준에 따라 만들어진 완전 이진 트리이고
    - 우선순위큐는 리스트에 넣게되고 기준이 되는 우선순위가 가장 빠른 것 부터 해결하는 방법이다.
    
    +)
    
    - 우선순위 큐는 힙을 이용해서 구현
- 피보나치 수열을 구하는 방법 ( 재귀,DP )
    
    
    - 피보나치 수열을 구하는 방법에는 두 가지가 있다.
    - 첫 번째는 Top-down 으로 접근하는 방법이며, 큰 문제에서 부터 해서 값을 기억해두면서 풀어나가면 되고
    - 두번째는 bottom-up 방식으로 가장 작은 문제의 값을 구해서 점점 큰문제로 합쳐져 가는것 입니다.
- BFS vs DFS
    
    DFS는 깊이우선탐색으로 한 방향으로 쭉 찾아본 다음 더 이상 못 진행하는 경우에 돌아와서 다음 방향으로 진행하는 방식이다. 주로 재귀함수나 스택을 이용하여 구현한다.
    
    BFS는 너비우선탐색으로 현재 위치에서 갈 수 있는 모든 노드를 탐색하고 그 다음으로 넘어가는 방식이다. 주로 큐를 이용하여 구현한다.
    
- 퀵 정렬 vs 힙 정렬
    
    
    **퀵 정렬** : 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
    
    (가장 대표적인 분할방식인 호어 분할 기준, 리스트에서 첫번째 데이터를 기준(피벗)으로 설정)
    
    - 시간 복잡도 : 평균적으로 O(NlogN) / 최악의 경우 O(N^2)
    - 장점 : 높은 성능. 머지 소트와 더불어 가장 많이 사용된다
    - 단점 : 최악의 경우 (이미 데이터가 정렬되어 있는 경우) O(N^2)의 성능을 가진다.
        
        (단, 파이썬과 같이 퀵 정렬을 기반으로 작성된 정렬 라이브러리를 제공하는 프로그래밍 언어들은 최악의 경우에도 O(NlogN)을 보장할 수 있도록 피벗값을 설정하는 추가적인 로직이 존재.)
        
    
    **힙 정렬 :** 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
    
    - 시간 복잡도 : 평균적으로 O(NlogN)
    - 장점 : 높은 성능. 퀵정렬과는 달리 최악의 경우에도 O(NlogN)의 시간복잡도를 가진다.
    - 단점 : 엘리먼트 개수가 증가할수록 swap연산이 힙소트보다 비약적으로 증가한다.
        
        (엘리먼트 수가 많은 경우 퍼포먼스 측면에서 무시할 수 없기때문에 크롬의 정렬알고리즘이 힙에서 퀵으로 대체됨)
        
- 버블 정렬 vs 선택 정렬 vs 삽입 정렬
    1. 버블 정렬
        - 한쪽으로 두개씩 계속 비교해가면서 가장 큰/작은 원소를 끝으로 이동시키면서 정렬한다
        - 장점 : 구현이 쉽다
        - 단점 : 비교와 교환이 많아서 비효율적. 대부분의 경우 최악의 성능
        - 최선, 최악, 평균 모두 O(n^2)
    2. 선택 정렬
        - 남은 리스트 중에서 최솟/최댓값을 찾고 앞으로 보내는 작업을 반복한다
        - 장점 : 비교는 많이 하지만 실제로 교환은 적게 일어나므로, 교환이 많이 일어나야 하는 상태(역순)에 효율적이다
        - 단점 : 장점과 반대로 거의 정렬되어있는 상태에서는 최악의 효율을 보여준다
        - 최선, 최악, 평균 모두 O(n^2)
    3. 삽입 정렬
        - 앞의 정렬되어 있는 부분을 이용해서 다음번 원소가 어디 들어갈지 정하는 정렬방법
        - 장점 : 같은 N제곱 복잡도를 가지는 선택정렬, 버블정렬에 비해 빠르다. 길이가 짧을 때는 아주 빠름
        - 단점 : 배열이 길어질수록 효율이 떨어진다
        - 최악-평균 : O(n^2), 최선 : O(n)
- 정렬(읽어보면 좋을 것 같은 내용)
    
    [NAVER D2](https://d2.naver.com/helloworld/0315536)
    

정렬 손코딩 나올 수도 있다

Java의 Array Sort는 Tim Sort로 구현되어 있다.

## 테스트

- 테스트 코드를 짜면 장점이 무엇인지
    
     : 오류를 미리 찾을 수 있다. 즉, 유지보수비용이 줄어든다.
    
    : 자연스럽게 더 작은 단위로 함수를 작성하게 된다.
    
     :
    
     :
    
    - 리팩토링하기 수월해진다.
    - 개발 사이클이 짧아집니다.
    
    이상경 :
    
    - 제품의 안정성을 높여주고,
    - 기능 추가 및 수정으로 인한 부작용을 줄일 수 있으며,
    - 디버깅을 용이하게 함으로써, 결과적으로 생산성을 높인다는 장점이 있다.
    
     :
    
    - 서비스를 안정적으로 운영할 수 있다.
    - 효율적인 코드를 짜게해준다.
    - 디버깅 시간을 줄여준다.
    
    [5 reasons why testing code is great](https://www.educative.io/edpresso/5-reasons-why-testing-code-is-great)
    
     :
    
    - 테스트를 크기별로 만들 수 있어서 유지보수의 용이함
    - 빠르게 잘 못 된 부분을 찾을 수 있음
    - 맹신하지 않도록 한다.
    - 년차가 적은 개발자들은 필수라고 생각하는 성향이 강하고, 년차가 많은 개발자들은 필요할 때만 도입하는 것이 좋다고 생각하는 통계도 있다.
- 테스트 커버리지에 대해서 어떻게 생각하는지
    - Code Coverage? 테스트 케이스가 얼마나 충족이 되었는가
    - 코드 커버리지로 누락된 부분을 보고 실행되지 않은 코드를 확인가능하다.
    - 단점) 사용하지 않은 소스코드가 있으면 측정이 불가능하다. 코드 커버리지는 프로그램 실행을 하여 측정하기 때문에 구현이 완료되지 않은 소스코드나 개발 스첵에 기능이 빠져있으면 측정이 힘들다.
    
    - 테스트 케이스가 어느정도로 코드를 테스트하는 지를 수치로 나타낸 것이며, 조건 커버리지, 결정 커버리지 , 구문커버리지 등이 있다.
    - 커버리지가 100% 가 된다는 것이 버그가 없는 코드라는 것을 의미하는 것은 아니다.
- TDD 란 무엇이며 어떠한 장점이 있는가?
    - TDD(테스트 주도 개발) : 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나로,
        
        테스트 코드를 먼저 작성하고 그에 통과하기 위한 코드를 작성하는 방식의 개발 방식이다.
        
    - 장점 : 테스트 코드를 먼저 작성함으로써 기능에 대해 철저히 구조화시킨 코드 작성이 가능하다.
        
        또한, 디버깅 시간의 단축함으로써 자원과 비용을 절약할 수 있다.
        
    
    - 테스트를 기반으로 코드를 만드는 것이다.
    - 미리 나올 값을 예상하고 만들기 때문에 단위별로 만들 때 용이하다.
    - 모든 코드에 대해 테스트 코드부터 만드는 것이라 더 많은 개발시간을 소요시킨다.

## 데이터베이스

### RDBMS

- ACID 란?
    
    
    데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질.
    
    - 원자성(Atomicity) : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
    - 일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
    - 독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
    - 지속성(Durability) : 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
    
    ACID 데이터베이스 트랜잭션이 최소 단위를 보장하는 속성들이다.
    
    - 원자성 ( Atomicity ) : 트랜잭션이 실행되었을때, 모두 다 되거나, 모두 적용되지 않아야 한다. ( 일부만 적용되면 안된다는 의미 )
    - 일관성 ( Consisitency ) : 트랜잭션 사용 전후에 해당 부분의 모든 데이터 모델의 제약조건들이 변화가 있어서는 안된다는 의미입니다.
    - 독립성 ( Isolation ) : 트랜잭션이 진행될 때 다른 작업이 해당 트랜잭션에 영향을 주면 안되고 독립적으로 실행되어야 합니다.
    - 지속성 ( Durability ) : 트랜잭션이 적용된 이후로 다른 작업이 없다면 그 값은 계속 유지되어야 합니다.
- DB Index란?
    1. 테이블에 저장된 데이터를 빠르게 조회하기 위한 데이터베이스 객체
    2. 테이블의 정렬 속도를 향상시켜주는 장점이 있습니다.
    3. CUD의 경우에 성능 저하를 불러일으킬 수 있습니다.(인덱스의 크기가 비대해져서)
    
    - 이름처럼 빠르게 데이터를 찾기위해 만들어둔 길잡이
    - 너무 많이 만들어두면 기능이 좋지 않음
    - B-Tree 등을 사용해서 만듭니다.
- 정규화
- 트랜잭션
- JOIN
- ORM

### NoSQL

- NoSQL 이 빠른 이유는? ( 항상 빠르지는 않다. )
    
    
    - 데이터를 사용하는 형식 그대로 저장하기 때문에 이를 변환하는 과정이 없어서 빠릅니다.
    - 제약 조건 검사가 없어서 더 빠르게 진행됨니다.
- RDBMS vs NoSQL
- MongoDB에서 자동으로 삽입되는 id를 제외하는 방법은? 당근마켓 면접

## 언어

### JavaScript

- Object.create의 역할은 무엇인가요?
    
    특정한 프로토타입과 프로퍼티를 가지는 새로운 객체를 생성하는 메소드로, class가 나오기 전까지 상속을 구현하기 위해 사용되었다.
    
    Object.create로 객체의 상속을 구현할 수 있다.
    
- 자바스크립트에서 모듈내의 private한 속성을 만드는 방법을 아는대로 쓰세요.
    - 객체를 리턴하는 즉시실행함수, 클로저를 이용
    - 생성자 함수에서 지역변수 사용
    - class의 private class fields → 필드명 앞에 `#`를 붙이면 됨 (ES2019)
- JS에서 재귀호출로 인한 stack overflow를 막을 수 있는 방법은?
    
    꼬리 물기 최적화를 하여 실행 컨텍스트가 계속 쌓이지 않게 할 수 있다.
    
    [꼬리 물기 최적화(Tail Call Optimization)란?](https://velog.io/@yesdoing/%EA%BC%AC%EB%A6%AC-%EB%AC%BC%EA%B8%B0-%EC%B5%9C%EC%A0%81%ED%99%94Tail-Call-Optimization%EB%9E%80-2yjnslo7sr)
    
- closure 와 스코프관계를 설명해보세요.
    
    [Closure | PoiemaWeb](https://poiemaweb.com/js-closure)
    
    [변수의 유효범위와 클로저](https://ko.javascript.info/closure)
    
    모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다.
    
    클로저는 함수와 그 함수의 렉시컬 스코프의 조합이다.
    
    클로저 함수로 그 함수가 생성된 시점의 지역변수들에 접근할 수 있다.
    
    스코프는 자바스크립트 엔진이 참조의 대상이 되는 식별자를 검색할때 사용하는 규칙의 집합.
    
    함수가 어디에 선언되었는지에 따라 결정되는 스코프를 렉시컬 스코프라고 하는데,
    
    **클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때도 그 스코프에 접근할 수 있게 하는 기능**을 말한다.
    
    ```
    function A(){
        var a=1;
        function B(){
            return ++a;
        };
        return B;
    };
    ```
    
    위의 경우처럼 A함수에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지않는 현상
    
    스코프는 식별자에 대한 유효범위
    
    - 클로저는 스코프 밖에서도 접근이 가능한 현상
    
    클로저란: 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상. ( 원래대로라면 GC에 의해 제거되어야 하지만! )
    
- `==` 보다, `===` 를 써야할때는?
    - 대부분 `==` (Equality Operator)보다는 `===` (Strict Equality Operator)를 사용하는 것이 더 나은 방법이다.
    - `==`는 타입이 다를 경우 강제 형변환을 해서 비교하기 때문에 예상과 다른 경우가 있다.
- ES6의 Class extends 내부 동작원리에 대해서 설명해보세요.
    
    `extends` 키워드는 겉으로 보기에는 클래스 기반의 상속을 해주는 것으로 보이지만, 자바스크립트는 프로토타입 기반의 언어이기 때문에 내부적으로는 프로토타입 체인을 이용해 상속이 이루어진다.
    
    코드로 나타내면 다음과 같이 진행된다
    
    ```
    function Car (name) {
        this.name = name;
    }
    
    function Model (name, brand) {
        Car.apply(this, arguments); // 부모 객체의 constructor 호출 : super();
        this.brand = brand;
    }
    
    // 부모 객체의 prototype을 상속
    Model.prototype = Object.create(Car.prototype);
    
    // 자식의 prototype.constructor에 자식을 지정
    Model.prototype.constructor = function Model(name, brand) {
        Car.apply(this, arguments);
        this.brand = brand;
    }
    ```
    
- 객체를 탐색하는 방법에 대해서 2가지를 작성해보세요.
    
    `for in` : 열거 가능한 속성을 순회한다. 객체의 key를 반복한다. [[Enumerable]]이 true여야 한다.
    
    `for of` : 객체의 value를 반복한다. Symbol.iterator 속성을 가지고 있어야 한다.
    
    Object.keys(), Object.values(), Object.entries() 도 가능
    
- NodeList 타입을, Array에 있는 reduce메서드를 사용하는 방법은?
    - NodeList 타입을 Array 타입으로 변환한다. Array.from() 사용
    - [ ]  [ ].reduce.apply(NodeList, arguments) 처럼 apply 이용
- 기존의 함수와 arrow 함수의 this가 결정되는 방식을 설명해보세요.
    
    function 함수는 다이나믹 바인딩
    
    - 그냥 호출되는 경우 : 글로벌 객체에 바인딩된다 (window객체)
    - 메소드로 호출되는 경우 : obj.foo() 처럼 메소드로 호출되면 호출한 객체가 바인딩된다
    - 생성자 함수로 호출되는 경우 : 생성된 객체에 바인딩된다
    - call, apply, bind 함수를 사용하는 경우 : 지정한 것으로 바인딩된다
    
    arrow 함수는 스태틱 바인딩
    
    - 선언할 때 this가 정해진다
    - 언제나 상위 스코프의 this를 가리킨다
    
    - 기존의 함수에서 this는 전역 객체를 가리킨다. (메서드 호출, bind함수 등의 상황을 제외하면)
    - arrow 함수는 실행 컨텍스트가 생성될 때 this 바인딩의 과정이 제외되었기 때문에 가장 가까운 상위 스코프의 this를 가리키게 된다.
- immutable과 mutable은 무엇이 다른것인가요?
    
    immutable 변경할 수 있는 값. 원시형 타입들은 값을 바꿀 수 없다
    
    mutable 변경할 수 있는 값. 참조형 타입들은 값을 바꿀 수 있다
    
    immutability가 중요한 이유 : 객체의 값을 의도치 않게 변경하기 쉽기 때문에 프로그램을 복잡하게 만들고, 유지보수 비용을 증가시킨다
    
- undefined와 null의 차이점을 설명하세요.
    - undefined : 값이 아직 정해지지 않은 상태.
    - null : 의도적으로 빈 객체를 할당한 상태.
    - typeof를 해보면 undefined → undefined, null → object로 표시된다. (버그로 간주한다)
    
    - undefined는 자바스크립트 엔진에 의해 초기화된 값으로, 선언은 되었으나 값이 할당되지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 반환된다.
    - null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다.
        
        (의도적으로 undefined를 할당하는 것은 권장되지 않는다.)
        
- 아래처럼 동작하는 flatten함수를 reduce를 활용해서 만들어보세요.
    
    ```
    // 문제
    const arr = [[1, 2], [3, 4], [5, 6]];
        const flattenedArray = flatten(arr);
        console.log(flattenedArray)  //[1, 2, 3, 4, 5, 6];
    ```
    
    ```
    function flatten(arr) {
        return arr.reduce((acc, cur) => {
            // return [...acc, ...cur]; 이것도 가능
            return acc.concat(cur);
        }, []);
    }
    ```
    
- 객체를 복사해서 새로운 객체를 만들고 싶습니다. 코드를 구현해보세요. (객체의 깊이는 1단계만 있다고 가정)
    
    ```
    Object.assign({}, obj);
    
    // 참고 : 깊은 복사는 JSON으로 구현할 수 있다
    // JSON.parse(JSON.stringify(obj));
    
    //
    new Object({...obj})
    ```
    
- Array.from 이 모든 브라우저에서 동작하도록 polyfill코드를 만들어보세요.
    
    [https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from#%ED%8F%B4%EB%A6%AC%ED%95%84](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from#%ED%8F%B4%EB%A6%AC%ED%95%84)
    
- prototype 의 동작방식에 대해서 설명해보세요.
    
    자바스크립트의 모든 객체는 프로토타입이라는 부모객체를 가진다. 프로토타입은 객체 또는 null이며, 객체를 생성한 생성자 함수의 프로토타입 속성이 할당된다.
    
    프로토타입 또한 객체이기 때문에 프로토타입 객체를 가진다. 이러한 특성 때문에 프로토타입은 상위 프로토타입으로 계속 연결되어있는 구조가 되고, 이를 프로토타입 체인이라고 한다.
    
    다른 여러 객체들이 같은 객체를 프로토타입으로 참조할 수 있기 때문에 공유 속성이나 상속 등에 활용된다.
    
- 순환되는 캐로셀UI의 구현 원리에 대해서 설명해보세요.
    
    캐로셀 라이브러리의 코드를 보고 비슷하게 구현하고자 했던 적이 있었는데, 그 때는 다음과 같이 구현했다.
    
    1. 이미지 리스트 양 끝에 반대쪽 끝 이미지를 한 장 더 추가한다 (D A B C D A)
    2. 마지막 이미지에서 한번 더 이동하면 첫 번째 이미지가 나오는데, 이 때 이동이 끝날 때 첫 번쨰 이미지로 애니메이션 없이 이동시킨다 (사용자는 움직이지 않는 것처럼 보인다)
    
    큐를 이용한다.
    
    1. 첫번째 아이템을 큐에서 dequeue하여 변수 currentImage에 저장하고 화면에 렌더링한다.
    2. currentImage의 data를 큐에 enqueue하고 1로 돌아간다.

- Event 객체에 대해서 설명해보세요.
    
    이벤트는 웹 API 중 하나로, DOM에서 사용자가 발생시킬 수도 있고, 자바스크립트로 직접 발생시킬 수도 있다. addEventListener로 이벤트가 발생했을 때 처리할 수 있으며, 인자로 이벤트 객체를 받는다.
    
    이벤트 객체는 발생한 이벤트에 대한 정보를 갖고 있는데, 이벤트의 타겟, 상태 등을 알 수 있다.
    
- 비동기의 장점을 설명해보세요.
    
    비동기 작업을 하는 동안 또 다른 작업을 동시에 할 수 있기 때문에 많을 일을 할 수 있다
    
- 본인이 즐겨하는 디버깅 방법을 설명해보세요.
    
    일단 코드를 보고 의심되는 부분에서 로그를 찍어본다. 그래도 못찾을 것 같은 경우 또는 예측하기 어려운 경우에는 개발자도구의 디버깅 툴을 이용한다. 코드에 debugger; 를 추가하고 프로그램의 진행에 따른 상태변화를 본다
    
- bind 가 필요한 상황을 간단한 코드로 보여주세요.
    
    ```
    class Counter {
        constructor(button) {
            this.count = 0;
    
            // bind를 사용하지 않으면 this는 button을 가리킨다
            button.addEventListener('click', handler.bind(this));
        }
    
        handler() {
            this.count++;
        }
    };
    ```
    
    ```
    // bind를 사용하여 상위 컨텍스트의 this를 내부함수에 전달할 수 있다.
    
    var obj = {
        outer: function () {
            console.log(this);
            var innerFunc = function() {
                    console.log(this);
            }.bind(this);
            innerFunc();
        }
    };
    obj.outer();
    ```
    
- CommonJS 스펙에 대해 설명해보세요.
    
    commonJS 모듈의 내보내기, 가져오기 방법
    
    - 내보내기 : module.exports의 프로퍼티를 추가하거나 내보낼 객체로 치환한다
    - 가져오기 : require() 함수로 가져올 파일의 module.exports를 가져온다
- node의 middleware의 동작방식을 설명해보세요.
    
    미들웨어는 node에서 중간처리를 위한 함수입니다.
    express의 use() 또는 라우터에서 미들웨어를 등록할 수 있고 먼저 오는 미들웨어가 먼저 실행됩니다. 미들웨어 내부에서는 next를 호출하면서 다음 미들웨어를 동작시킬 수 있고, req, res객체가 그대로 전달됩니다. 그리고 request가 시작되고 response로 종료될 때까지 진행됩니다.
    
- 클로저로 동작되는 상황을 예시코드로 보여주세요.
    
    ```
    function getRandomAdder() {
        const randomNum = Math.random();
    
        return function(num) {
            return num + randomNum;
        }
    }
    
    const add = getRandomAdder();
    
    add(100);
    ```
    
- yarn과 npm은 무엇인가요?
    
    둘 다 패키지 매니저로 프로젝트의 의존성 관리를 도와주는 툴.
    
    둘 다 package.json 설정파일을 생성하고, 설치된 패키지 버전을 각각 yarn.lock, packge.lock 파일로 관리한다.
    
- 리플로우(reflow), 리페인트(repaint)
    - Reflow : 노드의 수치를 계산 후 렌더 트리를 재생성하는 과정
        - 리플로우가 일어나는 경우
            - 노드의 추가 또는 제거, 요소의 위치 or 크기 변경 시
            - 요소의 크기 변경 시.(margin, padding, border, width, height, 등..)
            - 폰트 변경 과(텍스트 내용) 이미지 크기 변경(크기가 다른 이미지로 변경 시)
            - 페이지 초기 렌더링(최초 Layout 과정)
            - 윈도우 리사이징
        - 리플로우 최적화
            - 애니메이션이 들어간 노드는 가급적 position:fixed 또는 position:absolute로 지정
            - css를 하나씩 바꾸지 말고 cssText 또는 클래스로 한번에 바꾸기
    - Repaint : 만들어진 렌더 트리를 그리는 과정. 리플로우가 일어난 뒤에 발생
- ES6 클래스는 무엇인가?
    - 함수의 한 종류로서, 객체를 생성하기 위한 템플릿을 정의한다.
    - 실제 구현은 프로토타입을 이용하도록 되어있다.
- 클래스의 this는 함수의 this와 무엇이 다른가?
    
    
    - 클래스의 this는 클래스를 통해 만들어진 인스턴스를 가르키지만
    - 함수의 this는 일반적으로 전역 객체를 가르킨다.
    
    - 클래스 : 만들어진 객체를 가리킨다
    - 함수 : 함수를 호출할 때 동적으로 바인딩된다
- var, let, const의 차이
    - var : 함수 스코프, 호이스팅 O, 재할당 O
    - let : 블록 스코프, 호이스팅 X, 재할당 O
    - const : 블록 스코프, 호이스팅 X, 재할당 X, 선언할 때 초기화해야 함
- 아래 함수의 실행 결과는?
    
    ```
    function test() {
      console.log(a); // (1)
      console.log(b); // (2)
      var a = 1;
      const b = 2;
    }
    ```
    
    1. : undefined
    2. : Reference Error 발생 (cannot access ‘b’ before initialization)
- apply(), call(), bind()의 차이점
    
    
    - call : 메서드의 호출 주체인 함수를 즉시 실행하는 메서드. 이때 call 메서드의 첫번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개 변수로 한다.
    - apply : call 메서드와 기능적으로 완전히 동일하나, 두번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 차이가 있다.
    - bind : call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하는 메서드.
- 일급시민, 일급객체, 일급함수란?
    - 1급시민의 조건은 다음과 같다
        - 변수에 담을 수 있다.
        - 함수(혹은 메소드)의 인자(매개변수, Parameter)로 전달할 수 있다.
        - 함수(혹은 메소드)의 반환값(return)으로 전달할 수 있다.
    - 1급객체란, 1급시민의 조건을 충족하는 객체
    - 1급함수란, 1급시민의 조건을 충족하는 함수
        - 몇몇 학자들은 다음과 같은 추가적인 조건을 요구한다.
            - 런타임(runtime) 생성이 가능하다
            - 익명(anonymous)으로 생성이 가능하다
    - 자바스크립트의 함수는 1급 객체이면서 1급 함수다
        - 고차 함수가 가능
- 익명함수와 아닌 함수의 차이점
    - 익명 함수는 일반적으로 변수에 할당해서 사용한다
    - 함수 표현식으로 익명함수를 변수에 할당
        
        ```
        const foo = function() {
            return 'foo';
        }
        ```
        
    - 함수 표현식으로 기명함수를 변수에 할당
        
        ```
        // 이 경우는 함수를 foo로만 호출 가능하다
        // bar는 에러가 발생하면 stack trace에서 표시된다
        const foo = function bar() {
            return 100;
        }
        ```
        
    - 이렇게 익명함수를 변수에 할당하는 경우, 함수 호이스팅이 일어나지 않는다. 즉 함수가 선언된 부분 이전에는 함수를 호출할 수 없다
- 즉시실행함수란 무엇이고 왜 쓰는지?
    - 즉시실행함수의 형태
        
        ```
        (function () {
            // statements
        })();
        ```
        
    - 즉시실행함수 내부에서 정의한 변수 전역스코프에 정의되지 않고, 함수 내부에서만 정의된다.
    - 그래서 전역환경에서 변수 충돌을 방지할 수 있다.
    - 주로 모듈의 기능을 구현할 때 사용
    
    상경
    
    - 즉시실행함수란 함수 표현식을 즉시 실행하는 것을 의미한다
    - 사용이유 : 일반적으로 전역 스코프를 오염시키지 않기 위해 사용한다. 변수를 전역 스코프에 선언하지 않음으로써 충돌을 방지할 수 있다.
    - IIFE안에서 클로저를 생성하면 private 데이터를 만들 수 있고 외부에서 접근할 수 없다. 흔히 말하는 모듈 패턴이 바로 이 방식에 의존한다.
    - 동일한 전역 변수를 갖는 2개의 라이브러리를 사용한다고 했을 때 충돌을 해결하기 위해 사용할 수도 있다.
- 원시 자료형
    - 숫자
    - 문자
    - 불리언
    - null과 undefined
    - Symbol
    - BigInt

- 이벤트 루프, 태스크 큐 (node.js는 무엇이 다를까요?)
    
    [이벤트 루프와 매크로·마이크로태스크](https://ko.javascript.info/event-loop)
    
    [https://chanmi-lee.github.io/articles/2020-06/JavaScript-Visualized-Event-Loop](https://chanmi-lee.github.io/articles/2020-06/JavaScript-Visualized-Event-Loop)
    
- 가비지 컬렉션: 네이버 파이넨셜 면접 질문
    
    js의 메모리 생존주기
    
    - 필요할 때 할당 (값을 선언하면 자동으로 할당)
    - 사용
    - 필요없어지면 해제
    
    JS 같은 고수준 언어들은 GC를 통해 더 이상 필요하지 않은 메모리를 찾아 삭제한다.
    
    - GC에서 필요 없어진 메모리를 찾는 알고리즘
        - 참조 카운팅: 더 이상 필요없는 오브젝트 = 어떤 다른 오브젝트도 참조하지 않는 오브젝트로 정의하고 수집한다.
            
            ```
            let x = {
                a:{
                    b:2
                }
            }
            let y = x.a
            // x.a는 두 개의 참조를 가진다.
            x = null
            // x가 null 이기 때문에 이제 x.a는 한 개의 참조를 갖는다( y )
            // 오브젝트의 a 속성이 y 변수에 의해 참조되므로 메모리가 해제되지 않는다.
            y = "bye"
            // 메모리 해제!
            ```
            
            - 단점: 순환 참조
            
            ```
            function f(){
                let o = {}
                let o2 = {}
                o.a = o2
                o2.a = o
                return "??"
            }
            f()
            // o와 o2는 서로 참조하는 순환 구조이고, f 함수 호출 이후
            // 더 이상 필요없는 오브젝트이지만 메모리가 회수 되지 않는다.
            ```
            
        - 표시하고 쓸기(Mark and sweep): 더 이상 필요없는 오브젝트 = 닿을 수 없는 오브젝트로 정의한다.
            1. root (global)정보를 수집하고 이를 mark(표시, 기억)한다.
            2. 루트가 참조하는 모든 객체를 방문하고 이를 mark 한다.
            3. mark 된 모든 객체에 방문하여 그 객체들이 참조하는 객체도 mark 한다.
            4. 도달 가능한 모든 객체를 방문할 때까지 반복한다.
            5. mark 되지 않은 모든 객체를 메모리에서 삭제한다.
            
            ![%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20CS%20%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB%20854772344ac04c9aaa020f9121f34870/Untitled.png](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20CS%20%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB%20854772344ac04c9aaa020f9121f34870/Untitled.png)
            
            %E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20CS%20%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB%20854772344ac04c9aaa020f9121f34870/Untitled.png
            
            - 단점: 메모리 파편화
            
            ![%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20CS%20%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB%20854772344ac04c9aaa020f9121f34870/Untitled%201.png](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20CS%20%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB%20854772344ac04c9aaa020f9121f34870/Untitled%201.png)
            
            %E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20CS%20%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB%20854772344ac04c9aaa020f9121f34870/Untitled%201.png
            
            위와 같이 메모리가 조각난 상황을 Fragmentation이라고 한다. Garbage가 존재하던 메모리 공간이 제거된 후에는 비어있게 되어 메모리 전체를 봤을 땐 충분한 공간이 있는 것처럼 보이지만 메모리 할당이 불가능한 상황을 유발한다.
            
            ⇒ Compact 과정을 통해 해소 가능.
            
        - Mark sweep compact
    
    참조
    
    [https://teraphonia.tistory.com/800](https://teraphonia.tistory.com/800)
    
    [https://ko.javascript.info/garbage-collection](https://ko.javascript.info/garbage-collection)
    
- Promise: 당근마켓 화상면접

### TypeScript

- JavaScript와의 차이점
- TypeScript 를 요즘 많이 쓰는이유 ? 내가 쓰는 이유 ?
- 타입 vs 인터페이스
- 추상 클래스 vs 인터페이스
- 제네릭 이란 ?
    
    [TypeScript: 제네릭(Generic)](https://hyunseob.github.io/2017/01/14/typescript-generic/)
    
    인터페이스의 중복 선언 및 상속을 하지 않기 위해 인터페이스의 타입 란을 비워 놓는 것으로, 원하는 타입의 인터페이스로 선언하여 사용할 수 있는 장점이 있다
    

## React

- Redux란
    1. 자바스크립트 앱의 state를 관리해주는 라이브러리
    2. React, jquery, anguler과 같은 프레임워크에서 사용 가능함 (**리덕스는 리액트만을 위한 것이 아님)**
    3. **상태관리를 하는 전용 장소(store)**에서 상태를 관리하고, React 컴포넌트는 그걸 보여주기만 하는 용도로 쓰인다.
    4. 단방향 데이터 흐름(unidirectional data flow)’으로 진행됨
    5. **Action Creator > Action > dispatch > Reducer > State**
- 컴포넌트 단위를 어떻게 나눌 것 인가?
- 바닐라 js vs react
    
    [프레임 워크는 Vanilla JavaScript만큼 빠르지 않습니다.](https://ichi.pro/ko/peuleim-wokeuneun-vanilla-javascriptmankeum-ppaleuji-anhseubnida-106614463010451)
    
- React의 virtual DOM 은 뭐에요?
    
    UI의 상태를 가지는 가상의 DOM을 메모리에 만드는 프로그래밍 컨셉.
    
- React의 렌더링 방식은 무엇인가요?
    
    [NAVER D2](https://d2.naver.com/helloworld/9297403)
    
- React의 렌더링 과정에서 DOM 비교 방법 (어떻게 바뀐 DOM을 찾을 수 있을까요?)
    1. 일반 DOM 엘리먼트 비교
        - 루트 노드부터 비교한다
            - 다른 타입이면 트리 전체를 교체한다
            - 같은 타입이면 속성만 수정한 후, 자식 노드들에 대해 재귀적으로 처리한다
    2. key 속성이 있는 리스트 비교
        - key를 가지고 있다면, key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인한다
- React의 초기화면 느린 부분은 어떻게 해결해야해요?
    - 코드 스플리팅 : 한번에 모든 코드를 로드하기 보다는 사용자가 많이 사용하는 기능들은 하나의 청크로 두고, 잘 사용하지 않는 기능은 분리해서 동적으로 로드하도록 한다. (React.lazy)
    - Next.js와 같이 React에서 서버사이드 렌더링이 가능하도록 하는 라이브러리를 도입한다.
- 프로젝트에서 리액트를 썼다면 왜 리액트를 썻는지? 당근마켓 면접 다른 라이브러리(프레임워크)에 비교해서 기술적으로 어떤 장점이 있는지?
- SPA란: 당근마켓 면접

## 브라우저, FE

- 브라우저가 서버에서 html을 응답받고 난 다음의 과정
    1. DOM 트리 생성
        - html을 파싱하여 노드로 변환 후 트리 생성
        - 논블로킹 리소스 : 이미지, css
        - 블로킹 리소스 : script
            - `async`, `defer` 로 파싱이 블로킹되는 것을 막을 수 있음
    2. CSSOM 트리 생성
        - CSS 규칙을 트리로 변환
    3. 렌더 트리 생성
        - DOM 트리와 CSSOM 트리를 합쳐 렌더 트리를 만든다
        - 화면에 보이지 않고 자리도 차지하지 않는 엘리먼트들은 렌더 트리에서 제거된다
    4. 레이아웃
        - 렌더 트리 내의 노드들의 위치, 크기를 계산
        - 렌더 트리의 위치를 처음 계산하는 과정을 레이아웃이라고 하며, 같은 과정이 이후에 반복되는 경우엔 리플로우라고 부른다
    5. 페인팅
        - 레이아웃 과정에서 계산된 노드들을 화면상의 픽셀로 렌더링
- 브라우저의 렌더링 동작과정을 짧게 설명해보세요
    - **브라우저**는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 **렌더링**에 필요한 리소스를 요청하고 서버로부터 응답을 받습니다.
    - **브라우저의 렌더링** 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 **렌더** 트리를 생성합니다.
- 리플로우가 발생하면 성능이 좋지 않다. 개선방법은 어떤 것이 있는가?
    - [https://medium.com/better-programming/web-performance-dom-reflow-76ac7c4d2d4f](https://medium.com/better-programming/web-performance-dom-reflow-76ac7c4d2d4f)
    - 자바스크립트로 스타일을 변경할 때 한번에 변경한다
    - 가능한 DOM 트리의 하위 엘리먼트를 수정한다
    - offsetHeight 와 같은 리플로우를 유발하는 속성은 여러번 접근하지 않는다
    - 자주 위치가 변경되는 엘리먼트는 position: absolute 또는 fixed 로 설정한다
    - float보다 flex box를 사용한다
    - css의 display 속성보다는 visibility 속성을 사용한다
    - innerText보다 textContent를 사용한다
- 프론트엔드에서 성능이란 무엇일까?
    
    
    프론트엔드에서의 성능은 크게 로딩 성능과 렌더링 성능으로 나뉜다.
    
    - 로딩 성능 : 각 리소스를 불러오는 성능
    - 렌더링 성능 : 불러온 리소스를 화면에 보여주는 성능
    
    - FE에서 렌더링 성능을 나타내는 여러 지표들이 있다
        - [First Meaningful Paint](https://web.dev/first-meaningful-paint/) : 가장 큰 레이아웃 변화가 일어나기까지 걸리는 시간
        - [Largest Contentful Paint](https://web.dev/largest-contentful-paint/) : 가장 큰 텍스트 or 이미지 블록이 렌더링 되기까지 걸리는 시간
        - [First Contentful Paint](https://web.dev/first-contentful-paint/) : 처음 DOM(텍스트 or 이미지) 내용이 렌더링 되기까지 걸리는 시간
    - 크롬 개발자 도구 → lighthouse 에서 측정가능
- 웹사이트의 초기 로딩속도를 더 빠르게 하기 위해서 무엇을 해야 할까요?
    - 이미지 최적화 : 이미지 사이즈, 용량 최적화, 이미지 스프라이트 적용
    - 코드 최적화(번들링) : 코드 사이즈를 줄여준다, (글자 수 줄이기, 공백, 줄바꿈 제거)
    - CDN : 거리가 먼 서버에서 다운받기보다 가까운 캐시서버에서 다운로드
    - gzip: 크기가 큰 파일들을 압축하여 전달
- CORS란 무엇인지?
    - 동일 출처 정책(SOP)에 의해서 브라우저는 다른 출처의 리소스를 XMLHttpRequest로 다루는 것을 차단한다
    - 이러한 상황에서 다른 출처의 리소스를 공유하기 위해 사용하는 기술이 CORS이다
- CORS의 동작과정
    - simple request
        1. 클라이언트가 요청을 보내고 서버가 그에 따른 응답을 보내면
        2. 브라우저는 요청 헤더의 Origin과 응답 헤더의 Access-Control-Allow-Origin을 비교해서 허용하지 않는 Origin이면 차단한다
    - preflighted request
        1. simple request와는 다르게 먼저 OPTION 메소드로 허용되는 요청인지 체크한다. 이 때 원래 요청의 정보가 Access-Control-Request-Method/Headers에 기록되어 전송된다
        2. 서버는 응답으로 Access-Control-Allow-Origin/Methods/Headers 를 보내서 허용되는 요청을 알려준다
        3. 브라우저는 서버의 응답을 보고 원래 요청을 보낸다
    - Access-Control-Max-Age 응답 헤더는 얼마동안 preflight request의 응답이 캐시될 지를 나타낸다
- 리플로우,리페인트
    
    [What forces layout/reflow. The comprehensive list.](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)
    
    [https://d2.naver.com/helloworld/6856597#ch06](https://d2.naver.com/helloworld/6856597#ch06) → ‘리플로와 리페인트 최적화’ 부분 참고
    
    [https://zinee-world.tistory.com/295](https://zinee-world.tistory.com/295)
    
- cookie, localStorage, sessionStorage의 차이점은?
    - cookie와 비교한 webStorage의 특징
        - cookie는 서버로 매번 전송되지만, webStorage는 전송되지 않는다
        - cookie는 갯수와 용량의 제한이 있지만, webStorage는 제한이 없다
        - cookie는 만료시간이 있지만, webStorage는 없다
    - localStorage와 sessionStorage 비교
        - localStorage는 영구적으로 저장되지만, SessionStorage는 브라우저가 종료되면 삭제된다
        - localStorage는 같은 브라우저+도메인 내에서 접근이 가능하고, sessionStorage는 같은 브라우저라도 탭이 다르면 다른 탭의 스토리지에 접근할 수 없다.
- css 전처리기 장점? 당근마켓 면접
- inline과 block 차이? 당근마켓 면접
- 프론트엔드 개발에 있어서 중요하다고 생각하는 것은? 당근마켓 면접
- SSR 사용하는 이유는? 당근마켓 면접
    1. 초기
- SSR은 무엇인가요? 어떻게 구현하죠? 당근마켓 면접
    
    SSR(서버사이드렌더링)
    
    장점) 검색엔진 최적화가능,초기 렌더링속도가 빠르다
    
    [서버 사이드 렌더링 그리고 클라이언트 사이드 렌더링](https://asfirstalways.tistory.com/244)
    

## 암호화/보안

- JWT 란 ?
- OAuth 란 ?
- XSS 란 ? 이를 방지하기 위해서는 ?
- bcrypt
    
    [https://d2.naver.com/helloworld/318732](https://d2.naver.com/helloworld/318732)
    
    [https://auth0.com/blog/hashing-in-action-understanding-bcrypt/](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)
    
    [https://ko.wikipedia.org/wiki/블록_암호_운용_방식#전자_코드북_(ECB)](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_%EC%95%94%ED%98%B8_%EC%9A%B4%EC%9A%A9_%EB%B0%A9%EC%8B%9D#%EC%A0%84%EC%9E%90_%EC%BD%94%EB%93%9C%EB%B6%81_(ECB))
    
    [http://www.codeok.net/패스워드 보안의 기술](http://www.codeok.net/%ED%8C%A8%EC%8A%A4%EC%9B%8C%EB%93%9C%20%EB%B3%B4%EC%95%88%EC%9D%98%20%EA%B8%B0%EC%88%A0)
    
    - 비밀번호를 저장하기 위해 만들어진 해시함수
    - 원하는 만큼 암호화하는데 걸리는 시간을 늘릴 수 있다
    - 솔팅 : 원본 메시지에 임의의 문자열을 추가하여 다이제스를 생성하는 것
    - 키 스트레칭 : 생성한 다이제스트로 또 다시 다이제스트를 만드는 것을 반복하는 과정
    - bcrypt 암호화 과정
        - 솔팅 + 키 스트레칭 과정을 먼저 수행한다
        - 앞의 과정에서 나온 결과물과 원본 문자열을 ECB 방식으로 64번 암호화한다
- crypto
- sha-1, sha-256의 원리
    - SHA : 암호학적 해시 알고리즘
    - SHA-1 의 과정
        1. 512비트 패딩 적용 : 원래 메세지 + 연속된 0 + 메세지의 길이를 64비트로 늘린 수 = 512비트의 메세지
        2. 512비트 메세지를 32비트의 워드로 나눈다. 그러면 16개의 워드가 생긴다.
        3. 16개의 워드를 XOR, shift 연산을 통해 80개로 늘린다
        4. 정해진 값 5개를 초기화
        5. 80개의 워드를 돌면서 초깃값 5개를 정해진 계산에 따라 계속 재할당
        6. 최종적으로 5개의 값을 이어 붙이면 해시값이 된다.
- Block Ciper Mode (블록 암호 운용 방식)
    
    [https://ko.wikipedia.org/wiki/블록_암호_운용_방식](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_%EC%95%94%ED%98%B8_%EC%9A%B4%EC%9A%A9_%EB%B0%A9%EC%8B%9D)
    
    [https://m.blog.naver.com/PostView.nhn?blogId=jsky10503&logNo=221258926405&proxyReferer=https:%2F%2Fwww.google.com%2F](https://m.blog.naver.com/PostView.nhn?blogId=jsky10503&logNo=221258926405&proxyReferer=https:%2F%2Fwww.google.com%2F)
    
    - 블록 단위로 암호화할 때 어떻게 암호화할 지를 나타내는 절차. 블록 암호는 특정한 길이의 블록 단위로 동작하기 때문에, 가변 길이 데이터를 암호화하기 위해서는 먼저 이들을 단위 블록들로 나누어야 하며, 그리고 그 블록들을 어떻게 암호화할지 정해야 하는데, 이때 블록들의 암호화 방식을 운용 방식이라 부른다.
    - ECB : 가장 간단한 방식. 암호화하려는 메세지를 블록들로 나눈 뒤 각 블록에 같은 키로 각각 암호화한다
    - CBC : 널리 사용되는 방식. 이전 블록의 암호화 결과와 다음 블록의 메세지를 XOR한 다음 암호화한다. CBC는 암호화 입력 값이 이전 결과에 의존하기 때문에 병렬화가 불가능하지만, 복호화의 경우 각 블록을 복호화한 다음 이전 암호화 블록과 XOR하여 복구할 수 있기 때문에 병렬화가 가능하다.
    - 그 외에는 PCBC, CFB, OFB, CTR 등이 있다
- SQL Injection

## 기타

- package.json 이란?
    
    
    npm 으로 프로젝트에 대한 정보를 정의하는 곳으로, 특히 의존성등을 관리한다.
    
- package-lock.json 이란?
- FrameWork 와 library 의 차이
    
    
    - 프레임워크 : 일종의 뼈대, 틀.
        
        소프트웨어의 형식을 제공하며 **사용규칙이 정해져있다.**
        
        제공된 틀에 들어가 주어진 규칙을 지켜가며 사용하는 것.
        
    - 라이브러리 : 부품이 되는 소프트웨어의 집합.
        
        작은 기능들을 함수 단위로 만들어 제공하며, 이를 가져다 사용.
        
        프레임워크와는 달리 **어떻게 사용할지는 사용자가 결정한다.**
        
- 디자인 패턴이란 무엇인지 설명해보고 예시를 들어보세요.
    
    
    프로그래밍할때에 문제를 해결하고자
    
    코드의 구조들을 일정한 형태로 만들어 재이용하기 편리하게 만든 일종의 패턴.
    
    생성
    
    - 팩토리 패턴
    - 싱글톤 패턴
    
    구조
    
    - 옵저버 패턴
    - 전략 패턴
- MVC 패턴에 대해서 설명해 보세요.
- 동기, 비동기, 블록, 논블록에 대해서 설명해 보세요.
    - 동기 : 요청을 보낸 후 요청에 대한 응답(결과)를 받아야 다음 동작이 이루어지는 방식이다.
    - 비동기 : 요청을 보낸 후 요청에 대한 응답(결과)의 전달유무에 상관없이 다른 프로그램을 이용할 수 있다.
    - 블록
    - 논블록
- Git 이 동작하는 방식에 대해서 설명해 보세요.
- 읽기 좋은 코드란 무엇인가
    
    
    - 함수와 변수 이름을 통해 어떤 역할을 하는지 명확하게 이해 가능한 코드
    - 별다른 인수인계없이도 이해 가능하다면 읽기 좋은 코드라고 볼 수 있지 않을까요..?
- 함수형 프로그래밍 이란 ?
    
    
    프로그래밍 패러다임 중 하나로, 더 안정적인 프로그램을 만들기 위해 입력과 출력이 철저히 통제된 순수 함수 및 부수 효과를 최소화한 함수 위주로 프로그래밍 하는 것.
    
- 객체 지향 프로그래밍 이란 ?
    
    프로그램의 단위를 객체 ( Object ) 단위를 하여 책임을 분리하고 , 각자의 역활을 수행하게 프로그램을 만드는 것. 다형성을 통해 코드 재사용을 하며 상속을 통해 구현하는 방식입니다.
    
- 본인이 경험한 OOP관점에서의 객체분리를 설명하고, 느낀 장점을 말해보세요.
    
    가계부 만드는 프로젝트를 할 때 약간이나마 겪은 것 같은데, 느낀 장점은 역할 분리가 되면서 같은 역할의 코드만 모여있어서 보기 편했다는 점, 단점은 객체별로 서로 참조하고 있는게 늘어나다 보니 복잡해졌다는 점
    
- 본인이 생각하는 좋은 객체지향프로그래밍에 대해서 설명해보세요.
    
    각 객체들이 적절한 책임과 협력을 하는 프로그램
    
- 프로그래밍 요구사항을 받았을때, 구현하기 전까지 어떤 과정을 거치시나요?
    - 큰 앱의 경우 : 기능명세(백로그)를 만들어본다 → 백로그의 기능별로 작업
    - 간단한 프로그램의 경우 : 동작과정을 글로 적어본다 → 동작과정을 코딩
    
    - 구현에 사용할 기술 및 라이브러리 등을 조사한 뒤, 적합한 기술을 채택한다.
    - 구현 기능, 담당자, 우선순위, 예상 소요시간, 마감기한 등을 포함한 백로그를 작성한다.
    - 특정 주기 단위의(ex 일주일) 마일스톤을 정립한다
    - 팀 프로젝트라면 브랜치전략, 컨벤션 등을 회의를 통해 정립한다.

## 

### JAVA

- interface 와 abstract class 의 차이
    - interface(인터페이스)
        - 다중 상속
        - 추상 메서드, 상수만 선언 가능
        - 생성자, 일반 변수를 가질 수 없음
        - 팀별 협업시 추상메서드를 통해 결과를 예측하고 작업이 가능함(구현 객체의 동일성 보장)
    - abstract(추상 클래스)
        - 다중 상속 불가
        - 추상 메서드 1개 이상, 일반 변수, 일반 메서드 선언 가능
        - 생성자, 일반 변수 가질 수 있음
        - 메서드의 부분 구현이 가능(부분 구현된 메서드를 상속받아 확장시키기 위함)
- JVM 이란 ?
    1. 프로그램이 실행되면 OS로부터 프로그램이 필요로 하는 메모리를 먼저 할당 받습니다.
    2. 그리고 자바 컴파일러를 통해 개발자가 작성한 코드(.java)를 바이트 코드(.class)로 변환합니다.
    3. 다음 Class Loader에서 바이트 코드를 JVM에 로딩 시킵니다.
    4. 로딩 된 바이트 코드를 execution engine을 통해 기계어로 해석됩니다.
    5. 해석된 바이트 코드들은 runtime data areas에 배치되어 실질적인 수행이 이루어집니다.
- Garbege Collecter 란 ?
- Overriding vs Overloading
    - 오버로드는 하나의 이름의 메소드를 여러개의 입력 파라매터 종류를 만들어서 사용하는 것을 의미합니다.
    - 오버라이딩은 상속받은 기존의 메소드를 하위 클래스에서 재정의해서 사용하는 것을 의미합니다.
- Generic
    
    해당 클래스에서 사용할 타입을 외부에서 정하는 것을 의미한다.
    

### Express
